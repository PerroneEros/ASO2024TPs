üìÑ Unidad 1: Software e Ingenier√≠a del Software
Conceptos Clave
Software: Producto l√≥gico creado y mantenido por programadores.
Ingenier√≠a del Software (IS): Conjunto de procesos, m√©todos y herramientas para desarrollar software de calidad.
Importancia: El software influye en todos los aspectos de la vida moderna.
Particularidades del Software
Es un producto l√≥gico, no f√≠sico.
No se desgasta como el hardware.
Su "fabricaci√≥n" requiere m√°s intelecto que infraestructura.
Producto Final
Para el ingeniero: conjunto de programas, datos y artefactos.
Para el usuario: informaci√≥n √∫til y transformadora.
Dominios de Aplicaci√≥n
Sistemas
Aplicaci√≥n
Ingenier√≠a y ciencias
Software incrustado
Software de l√≠nea de productos
Web/Mobile
Inteligencia Artificial
El Proceso del Software
Capas: Herramientas, M√©todos, Proceso, QA
Actividades estructurales: Comunicaci√≥n, Planeaci√≥n, Modelado, Construcci√≥n, Despliegue
Actividades sombrilla: revisiones, QA, configuraci√≥n, mediciones
Pr√°ctica de la IS
Entender el problema
Planear la soluci√≥n
Ejecutar el plan
Examinar el resultado
Principios Generales
Valor, simplicidad, visi√≥n, reutilizaci√≥n, planeamiento, pensamiento

üìä Unidad 2: Modelos de Procesos
Proceso de Software
Estructura organizada para construir software.
Implica interacci√≥n entre usuarios, dise√±adores y herramientas.
Diferencias
Proceso: secuencia estructurada.
Ingenier√≠a: conjunto de pr√°cticas y tecnolog√≠as aplicadas.
Flujos del Proceso
Lineal: paso a paso.
Iterativo: mejoras en ciclos (ej. RUP).
Evolutivo: mejora basada en feedback (ej. prototipos, √°gil).
Paralelo: actividades simult√°neas.
Modelos Prescriptivos
Cascada
Modelo en V (verificaci√≥n y validaci√≥n)
Incremental
Evolutivo
Espiral (enfoque en riesgos)
Proceso Unificado (PU)
Fases: Concepci√≥n, Elaboraci√≥n, Construcci√≥n, Transici√≥n, Producci√≥n
Caracter√≠sticas: dirigido por casos de uso, centrado en arquitectura, iterativo e incremental
Elementos del PU
Trabajadores (qui√©n)
Actividades (c√≥mo)
Artefactos (qu√©)
Flujo (cu√°ndo)
Patrones de Proceso
Soluciones reutilizables a problemas comunes
Tipos: Etapa, Tarea, Fase
Ejemplos
En cascada, iterativo, basado en componentes, √°gil

üèãÔ∏è Unidad 3: Desarrollo √Ågil
Manifiesto √Ågil (2001)
Individuos sobre procesos
Software funcionando sobre documentaci√≥n
Colaboraci√≥n sobre negociaci√≥n contractual
Respuesta al cambio sobre seguir un plan
Filosof√≠a √Ågil
Entregas r√°pidas
Equipos peque√±os y motivados
Poca burocracia, m√°s comunicaci√≥n
Principios √Ågiles (12)
Entrega continua
Bienvenida al cambio
Software funcional como medida de progreso
Equipos autoorganizados
Simplicidad
Reflexi√≥n continua para mejorar
Factores Humanos
Colaboraci√≥n, respeto, confianza, organizaci√≥n propia
Procesos √Ågiles
XP (Extreme Programming): simplicidad, pruebas, programaci√≥n en pares
Scrum
Otros: DAS, DSDM, Cristal, FDD, Lean, Modelado √Ågil, PUA

ü™° Unidad 4: Comprensi√≥n y Modelado de Requerimientos
Objetivos
Entender al cliente
Evaluar factibilidad
Negociar una soluci√≥n
Especificar y validar los requerimientos
Recomendaciones
Identificar a los participantes
Formular preguntas clave (qu√© se espera, restricciones, beneficios, etc.)
Modelado de Requerimientos
Describe el "qu√©" del sistema, no el "c√≥mo"
Requisitos funcionales y no funcionales
Herramientas
Diagramas:
Actividad
Clases
Estado
Swimlane (canales)
Entidad-Relaci√≥n (DER)
Historias de Usuario
Casos de Uso (UML)
Buenas pr√°cticas
Minimizar acoplamiento
Visibilidad del sistema
Claridad y simplicidad

üåü Unidad 5: Calidad de Software
Lineamientos
Arquitectura basada en patrones
Representaciones claras
Modularidad y buenas interfaces
Notaci√≥n efectiva
FURPS (atributos de calidad)
Functionality: funciones, interoperabilidad, seguridad
Usability: facilidad de uso, est√©tica, documentaci√≥n
Reliability: robustez, disponibilidad, recuperabilidad
Performance: velocidad, escalabilidad, eficiencia
Supportability: mantenibilidad, flexibilidad, instalaci√≥n, adaptabilidad
Dise√±o de Calidad
Abstracci√≥n
Arquitectura
Patrones
Modularidad
Ocultamiento de informaci√≥n
Independencia funcional (alta cohesi√≥n, bajo acoplamiento)
Administraci√≥n de Calidad
Procesos probados
Buena gesti√≥n
Control de Calidad (QC)
Aseguramiento de Calidad (QA)
Dimensiones (Garvin)
Desempe√±o, Caracter√≠sticas, Confiabilidad, Conformidad, Durabilidad, Servicio, Est√©tica, Percepci√≥n
Costos de Calidad
Prevenci√≥n, Evaluaci√≥n, Fallas (internas y externas)
Revisiones
Informales: √°giles pero menos precisas
RTF (Revisi√≥n T√©cnica Formal):
Preparaci√≥n previa
Roles definidos (moderador, lector, escriba, autor, inspector)
Reportes
M√©tricas de revisi√≥n
Errores, esfuerzo, TPT, densidad
Diferencias
QC: verifica el producto
QA: verifica el proceso

üß™ Unidad 6: Estrategias de Prueba de Software
Definiciones principales
Pruebas (Testing): detectar errores en un programa mediante la ejecuci√≥n de pruebas.


Depuraci√≥n (Debugging): corregir errores hallados durante el testing.


Validaci√≥n: comprobar que el producto cumple las necesidades del usuario.


Verificaci√≥n: comprobar que el producto cumple las especificaciones.


Aspectos estrat√©gicos
Requerimientos cuantificables.


Objetivos de prueba claros.


Perfil de usuario.


Plan de pruebas con ciclos r√°pidos.


Software robusto y autoverificable.


Revisiones t√©cnicas efectivas.


Mejora continua.


Tipos de pruebas
Prueba Unitaria
Prueba de funciones o m√©todos de forma aislada.


Detectan errores temprano.


Facilitan el mantenimiento.


Funcionan como documentaci√≥n viva.


Prueba de Integraci√≥n
Prueba de interfaces entre componentes.


Se prueba la arquitectura ensamblada.


Prueba de Regresi√≥n
Verifica que los cambios no generen nuevos errores.


Tres tipos de casos de prueba:


Muestra representativa.


Funciones afectadas por los cambios.


Componentes modificados.


Prueba de Humo
Prueba r√°pida que detecta fallos graves.


Se ejecuta frecuentemente en proyectos cr√≠ticos.


Pruebas de Clase
Prueba de operaciones encapsuladas en clases.


Se prueba el comportamiento de estado.


Se requiere probar herencia y subclases.


Dobles de prueba (Test Doubles)
Dummy: relleno sin l√≥gica.


Stub: respuestas fijas.


Fake: implementaci√≥n simplificada.


Mock: verifica interacciones.


Spy: esp√≠a interacciones reales.


Pruebas de Validaci√≥n (E2E)
Simulan el uso completo por parte del usuario.


Verifican funcionalidad visible.


Resultados:


‚úÖ Cumple especificaciones.


üêû Lista de deficiencias.


Pruebas Alfa y Beta
Alfa: en el sitio del desarrollador.


Beta: en el entorno del usuario, sin intervenci√≥n del desarrollador.


Pruebas Adicionales
Recuperaci√≥n: evaluar recuperaci√≥n tras fallos.


Seguridad: vulnerar mecanismos de seguridad.


Esfuerzo: prueba l√≠mites de carga.


Performance: evaluar rendimiento.


Despliegue: probar en distintas plataformas.


Depuraci√≥n
Puede:


Corregir el error.


No encontrar la causa.


Seguir hip√≥tesis para descubrir el error.


Preguntas gu√≠a:


¬øEl error ocurre en otro lado tambi√©n?


¬øPuede generar nuevos errores la correcci√≥n?


¬øC√≥mo prevenir errores similares a futuro?


üîé Recomendaciones Finales
Repas√° con ejemplos cada modelo y proceso.
Practic√° diagramas: clases, actividades, estados.
Record√° las siglas y definiciones: FURPS, QA/QC, PU.
Simul√° explicar los conceptos a otra persona.
Revis√° las lecturas recomendadas de Pressman para ampliar.
GU√çA DE RESPUESTAS COMPLETA ‚Äì METODOLOG√çA DE SISTEMAS I
 Basado en el material PDF oficial

1. ¬øCu√°l es la diferencia entre la visi√≥n del producto por parte del ingeniero de software y del usuario final? ¬øPor qu√© ocurre esa divergencia?
El ingeniero ve el software como un conjunto de programas y datos t√©cnicos.


El usuario lo percibe como una herramienta que soluciona un problema.


La divergencia se da porque tienen intereses distintos: uno piensa en la construcci√≥n, el otro en el resultado y utilidad.



2. Enumere 3 desaf√≠os espec√≠ficos en el desarrollo de software para videojuegos frente al software empresarial.
Videojuegos: rendimiento gr√°fico, experiencia interactiva, prueba en m√∫ltiples dispositivos.


Empresarial: integraci√≥n con sistemas existentes, seguridad, mantenimiento de datos.



3. Nombre las principales diferencias entre el Modelo Evolutivo y el Modelo Espiral. ¬øEn qu√© circunstancias se aplican?
El evolutivo parte de una versi√≥n simple y mejora seg√∫n el feedback.


El espiral se centra en la gesti√≥n de riesgos y planificaci√≥n c√≠clica.


El evolutivo sirve para productos poco definidos; el espiral para proyectos cr√≠ticos o costosos.



4. ¬øQu√© diferencia hay entre los modelos Iterativo y Evolutivo? D√© ejemplos.
Iterativo: parte de un dise√±o base y se mejora en ciclos definidos.


Evolutivo: parte de algo b√°sico que se transforma seg√∫n necesidades.
 Ejemplos:


Iterativo: una app de notas que mejora en cada versi√≥n.


Evolutivo: un sitio web que arranca solo con productos y luego se le suma carrito y pago.



5. ¬øEs posible demostrar que un software es correcto? Justifique.
Te√≥ricamente s√≠, mediante t√©cnicas formales. Pero en la pr√°ctica es muy costoso o inviable aplicarlo a sistemas completos. Es m√°s viable demostrar partes cr√≠ticas.



6. ¬øQu√© es un software ‚Äúsuficientemente bueno‚Äù? D√© un ejemplo real.
Es aquel que cumple los requisitos funcionales y no funcionales b√°sicos, aunque no sea perfecto. Se prioriza la entrega a tiempo y el valor para el usuario.
 Ejemplo: una app de banco que funciona bien pero puede tener demoras o errores menores.



7. Describa la diferencia entre verificaci√≥n y validaci√≥n. ¬øAmbas usan dise√±o de casos de prueba?
Verificaci√≥n: verifica que el software cumple con lo especificado.


Validaci√≥n: verifica que el software satisface lo que el usuario necesita.


Ambas usan pruebas, pero con diferentes enfoques.



8. Explique la diferencia entre QC y QA.
QC (Control de Calidad): controla el producto, busca errores mediante pruebas.


QA (Aseguramiento de Calidad): se enfoca en el proceso para prevenir errores.



9. Describa un escenario donde ser√≠a m√°s apropiado un enfoque tradicional y otro donde conviene usar Agile.
Tradicional: sistema bancario, m√©dico o militar.


Agile: app de delivery o red social.



10. ¬øQu√© es la medida principal de avance en proyectos √°giles? ¬øPor qu√© es tan importante?
La medida principal es el software funcionando.


Es importante porque representa valor real entregado y permite validaci√≥n temprana y continua.



11. Compare ventajas y desventajas del modelo en cascada y del modelo iterativo.
Cascada: + claro, + organizado, pero - r√≠gido con retrocesos costosos.


Iterativo: + flexible, + mejora continua, pero puede derivar en sobrecostos.



12. ¬øQu√© son los patrones de proceso? ¬øC√≥mo contribuyen a la mejora continua?
Son soluciones reutilizables a problemas comunes.


Gu√≠an en buenas pr√°cticas y permiten estandarizar procesos exitosos.



13. ¬øQu√© tipos de patrones de proceso existen? D√© ejemplos.
De etapa (ej: comunicaci√≥n)


De tarea (ej: recabar requisitos)


De fase (ej: modelo espiral)



14. ¬øQu√© desaf√≠os pueden surgir al implementar metodolog√≠as √°giles en proyectos grandes?
Dificultad de coordinaci√≥n.


Comunicaci√≥n constante entre equipos.


P√©rdida de visi√≥n unificada del producto.



15. ¬øQu√© es la programaci√≥n en parejas (XP)? ¬øCu√°les son sus ventajas y posibles desaf√≠os?
Dos desarrolladores trabajan juntos: uno escribe, otro revisa.


Ventajas: mejora calidad, aprendizaje.


Desaf√≠os: puede parecer lento o ineficiente si no hay sinergia.



16. ¬øCu√°les son los roles principales de un equipo SCRUM? ¬øQu√© responsabilidades tiene cada uno?
Product Owner: prioriza requerimientos, representa al cliente.


Scrum Master: elimina impedimentos, facilita el proceso.


Equipo de desarrollo: construye el producto.



17. ¬øQu√© preguntas llevar√≠as a una reuni√≥n de relevamiento de requerimientos para un ‚Äúcarrito de compras‚Äù?
¬øQu√© productos se venden?


¬øRequiere login?


¬øM√©todos de pago?


¬øStock?


¬øCupones?


¬øM√©todo de env√≠o?


¬øRegulaciones?



18. ¬øQu√© materiales llevar√≠as para facilitar ese relevamiento?
Pizarra


Marcadores


Laptop


Plantillas de casos de uso


Post-its


Prototipos previos



19. Desarrolle un caso de uso completo para ‚Äúbuscar libros sobre un tema espec√≠fico en una librer√≠a en l√≠nea‚Äù.
Actor: usuario


Precondici√≥n: usuario entra al sitio


Flujo principal: ingresa tema ‚Üí sistema busca ‚Üí muestra resultados


Flujo alternativo: no hay resultados ‚Üí mostrar mensaje


Excepciones: sin resultados o error de conexi√≥n



20. Cree un DER para un sistema de facturaci√≥n simple en un negocio peque√±o.
Entidades: Cliente, Factura, Producto, Detalle_Factura


Relaciones:


Cliente 1‚ÜíN Factura


Factura 1‚ÜíN Detalle_Factura


Producto 1‚ÜíN Detalle_Factura



21. Haga un diagrama de clases correspondiente al mismo sistema.
Cliente: nombre, email


Producto: nombre, precio


Factura: nro, fecha, lista de DetalleFactura


DetalleFactura: cantidad, referencia a Producto, referencia a Factura
 Relaciones:


Un Cliente puede tener muchas Facturas.


Una Factura tiene muchos DetalleFactura.


Cada DetalleFactura referencia un Producto y una Factura.



22. ¬øQu√© son cohesi√≥n y acoplamiento? ¬øPor qu√© es ideal buscar alta cohesi√≥n y bajo acoplamiento?
Cohesi√≥n: qu√© tan bien se relacionan las funciones dentro de un m√≥dulo.


Acoplamiento: dependencia entre m√≥dulos.


Alta cohesi√≥n y bajo acoplamiento = f√°cil de mantener y escalar.



23. ¬øCu√°les son los principios generales de la ingenier√≠a de software?
Valor del software


Mantenerlo simple


Planificar reutilizaci√≥n


Pensar en el futuro


Otro usar√° tu producto



24. ¬øQu√© son las pruebas alfa y beta? ¬øCu√°l es su diferencia?
Alfa: se hacen en entorno controlado por el desarrollador.


Beta: se hacen con usuarios reales antes del lanzamiento final.






































MODELOS DE CICLO DE VIDA

1.Modelo en Cascada
Descripci√≥n: Secuencial. Fases: An√°lisis ‚Üí Dise√±o ‚Üí Codificaci√≥n ‚Üí Pruebas ‚Üí Mantenimiento.


‚úÖ Ventaja: Orden claro y estructurado.
‚ùå Desventaja: Dif√≠cil adaptarse a cambios durante el desarrollo.




 2.Modelo Incremental
Descripci√≥n: El sistema se desarrolla en partes o m√≥dulos funcionales.


‚úÖ Ventaja: Permite entregar versiones utilizables progresivamente.
‚ùå Desventaja: La integraci√≥n puede volverse compleja.



 3.Modelo de Prototipos
Descripci√≥n: Se crean versiones preliminares para comprender mejor los requisitos.


‚úÖ Ventaja: Ayuda a aclarar las necesidades del cliente.
‚ùå Desventaja: Riesgo de terminar con un dise√±o deficiente si el prototipo se convierte en el producto final.


 4. Modelo Espiral
Descripci√≥n: Iterativo, incorpora an√°lisis de riesgos en cada fase.


‚úÖ Ventaja: Ideal para proyectos grandes y complejos.
‚ùå Desventaja: Costoso y dif√≠cil de gestionar.



 5. Modelo RUP (Rational Unified Process)
Descripci√≥n: Basado en casos de uso y desarrollo iterativo.
 Etapas: Inicio ‚Üí Elaboraci√≥n ‚Üí Construcci√≥n ‚Üí Transici√≥n.
‚úÖ Ventaja: Flexible, bien documentado y adaptable.
‚ùå Desventaja: Requiere personal con experiencia.


 

6.Modelos √Ågiles (ej. Scrum, Extreme Programming - XP)
Descripci√≥n: Enfocados en colaboraci√≥n, entregas r√°pidas y mejora continua.
‚úÖ Ventaja: Flexibles, excelente respuesta al cambio.
‚ùå Desventaja: Requieren alta comunicaci√≥n y compromiso constante del cliente.
